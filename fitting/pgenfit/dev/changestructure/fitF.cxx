/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "fitF.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

ClassImp(fitF)

 fitF::fitF(const char *name, const char *title,
                        RooAbsReal& _x,
                        RooAbsCategory& _y,
                        RooAbsReal& _ineueff,
                        list<RooAbsReal*> listparms
                        ) :
   RooAbsPdf(name,title),
   x("x","x",this,_x),
   y("y","y",this,_y),
   ineueff("ineueff","ineueff",this,_ineueff)
 {
    int k=0;
    list<RooAbsReal*> ::iterator listparms_it;
    for (listparms_it = listparms.begin(); listparms_it != listparms.end(); listparms_it++){
        RooAbsReal* parms_it = (*listparms_it);
        //! initialize roorealproxy
        p[k]=new RooRealProxy(Form("p%d",k),Form("p%d",k),this,*parms_it);
        k++;
    }
 }

 fitF::fitF(const fitF& other, const char* name) :
   RooAbsPdf(other,name),
   x("x",this,other.x),
   y("y",this,other.y),
   ineueff("ineueff",this,other.ineueff)
 {
     for (Int_t i=0;i<nparsinit+3;i++){
         p[i]=new RooRealProxy(Form("p%d",i),this,*other.p[i]);
     }
     cout<<npar<<endl;
 }


 Double_t fitF::evaluate() const
 {

     neueff = ineueff;
     Double_t par0[knri*4+3];
     for (Int_t i=0;i<knri*4;i++){
         if (isparmsfix[i]!=2){
             par0[i]=*p[indexparsinit[i]];
         }else{
             par0[i]=parms[i];
         }
     }

     //! initial activity set to 1, background(off+slope) =0
     par0[knri*4] = 1;
     par0[knri*4+1] = 0;
     par0[knri*4+2] = 0;//slope

     Double_t par1[knri*4+5];
     for (Int_t i=0;i<knri*4;i++){
         if (isparmsfix[i]!=2){
             par1[i]=*p[indexparsinit[i]];
         }else{
             par1[i]=parms[i];
         }
     }
     //! initial activity set to 1, background(off+slope) =0
     par1[knri*4] = 1;
     par1[knri*4+1] = 0;
     par1[knri*4+4] = 0;//slope

     //! default random coincidence factor
     par1[knri*4+2] = *p[nparsinit];//randcoinf1n
     par1[knri*4+3] = *p[nparsinit+1];//randcoinfgt0n


     Double_t par2[knri*4+6];
     for (Int_t i=0;i<knri*4;i++){
         if (isparmsfix[i]!=2){
             par2[i]=*p[indexparsinit[i]];
         }else{
             par2[i]=parms[i];
         }
     }
     //! initial activity set to 1, background(off+slope) =0
     par2[knri*4] = 1;
     par2[knri*4+1] = 0;
     par2[knri*4+5] = 0;//slope

     //! default random coincidence factor
     par2[knri*4+2] = *p[nparsinit];//randcoinf1n
     par2[knri*4+3] = *p[nparsinit+1];//randcoinfgt0n
     par2[knri*4+4] = *p[nparsinit+2];//randcoinf2n

     Double_t t[1];
     t[0]=x;


     return 1 ;

 }





